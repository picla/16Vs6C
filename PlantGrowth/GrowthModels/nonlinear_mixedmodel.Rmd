---
title: "nonlinear_mixedmodel"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(stringsAsFactors = F)
library(tidyverse)
library(nlme)
knitr::opts_knit$set(root.dir = "/Volumes/nordborg/user/pieter.clauw/Documents/Experiments/UltimateQandD/")
```
```{r functions}
# Self-start function for power-law fit. This self-start for this model is not provided by Pinhero and Bates (2000), so I wrote one. Unfortunately, it often does not lead to convergence. Any suggestions would be welcome
fmla.pow <- as.formula("~(M0^(1-beta) + r*x*(1-beta))^(1/(1-beta))")
Init.pow <- function(mCall, LHS, data){
    xy <- sortedXyData(mCall[["x"]], LHS, data)
    if(nrow(xy) < 4) {stop("Too few distinct x values to fit a power-law")}
	r    <-coef(lm(log(y) ~ x, xy))[2]    # Use the slope from a log fit to the data as an initial guess for r
	M0   <- min(xy$y)		              # Use the minimum y value as an initial guess for M0
	beta <- 0.9	                          # give initial guess of beta as 0.9. don't use beta = 1, as it's undefined (1/0)
    value <- c(M0, r, beta) 
    names(value) <- mCall[c("M0", "r", "beta")]
 	return(value)
	}
SS.pow  <- selfStart(fmla.pow, initial = Init.pow, parameters = c("M0", "r", "beta"))

## self startv found online
powermodel=function(x,a,b,c)
{a+b*x^c}

powermodelInit=function(mCall,LHS,data){
xy=sortedXyData(mCall[["x"]],LHS,data)
lmFit1=lm(xy[,"y"]~1) #for "intercept", a
lmFit2=lm(log(xy[,"y"])~log(xy[,"x"])) #for b and c
coefs1=coef(lmFit1)
coefs2=coef(lmFit2)
a=coefs1
b=exp(coefs2[1])
c=coefs2[2]
value=c(a,b,c)
names(value)=mCall[c("a","b","c")]
value
}

SSpower=selfStart(powermodel,powermodelInit,c("a","b","c"))



```

```{r data}
lemna <- read_delim('Data/Growth/rawdata_combined_annotation_NO.txt', delim = '\t')
```
```{r data preparation}
lemna$ID <- paste(lemna$pot, lemna$experiment, sep = '_')
lemna$acn <- as.character(lemna$acn)
lemna$Area[lemna$Area == 0] <- NA

# only use accessions which have data for all replicates
acns_rep1 <- unique(lemna$acn[lemna$replicate == 'rep1'])
acns_rep2 <- unique(lemna$acn[lemna$replicate == 'rep2'])
acns_rep3 <- unique(lemna$acn[lemna$replicate == 'rep3'])

acns_rep123 <- intersect(intersect(acns_rep2, acns_rep3), acns_rep1)
lemna <- lemna[lemna$acn %in% acns_rep123, ]
```

```{r subset}
acns.nr <- 2
rep.nr <- 3
temp.nr <- 2

lemna.sub <- lemna %>%
  filter(acn %in% unique(lemna$acn)[1:acns.nr], replicate %in% unique(lemna$replicate)[1:rep.nr], temperature %in% unique(lemna$temperature)[1:temp.nr]) %>%
  drop_na(Area) %>%
  select(ID, acn, experiment, temperature, replicate, DAS_decimal, Area)

lemna.sub <- lemna.sub %>%
  mutate(DAS = round(DAS_decimal),
         acn = as.factor(acn),
         temperature = as.factor(temperature),
         replicate = as.factor(replicate),
         experiment = as.factor(experiment))

lemna.sub.grp.DAS <- groupedData(Area ~ DAS | ID, data = lemna.sub)

lemna.sub.grp <- groupedData(Area ~ DAS_decimal | ID, data = lemna.sub)
lemna.sub.grp$acn <- as.factor(lemna.sub.grp$acn)
lemna.sub.grp$temperature <- as.factor(lemna.sub.grp$temperature)
lemna.sub.grp$replicate <- as.factor(lemna.sub.grp$replicate)
```
```{r plot over all individuals}
theme_set(theme_bw())

pl <- ggplot(data=lemna.sub, aes(x=DAS_decimal,y=Area)) +
  geom_point(aes(col = temperature, shape = replicate), size=2) +
  geom_line(aes(group = ID, col = temperature))

```
```{r plot per accession}
pl + facet_wrap(~acn)
```



```{r nls}
ctrl <- nls.control(maxiter = 1000, warnOnly = T)
fm1.nls <- nls(Area ~ SSlogis(DAS_decimal, Asym, xmid, scal), data = lemna.sub, control = ctrl)
plot(fm1.nls)
```

```{r nlsList}
fm1.logis.lis <- nlsList(Area ~ SSlogis(DAS_decimal, Asym, xmid, scal), data = lemna.sub.grp, control = ctrl)
plot(fm1.logis.lis)
plot(augPred(fm1.logis.lis), level = 2)
```
```{r logistic nlme}
fm1.logis.lis.ranef <- as.data.frame(ranef(fm1.logis.lis))
nonconverge <- rownames(fm1.logis.lis.ranef[is.na(fm1.logis.lis.ranef$Asym), ])
lemna.sub.grp.conv <- lemna.sub.grp[!lemna.sub.grp$ID %in% nonconverge, ]

fm2.logis.lis <- nlsList(Area ~ SSlogis(DAS_decimal, Asym, xmid, scal), data = lemna.sub.grp.conv, control = ctrl)

fm1.logis.nlme <- nlme(fm2.logis.lis, data = lemna.sub.grp.conv)
fm1.logis.nlme
plot(fm1.logis.nlme)
plot(augPred(fm1.logis.nlme))
```
Clear heteroscedasticity
much more 6C samples are not-converging compared to 16C



```{r nlme power}
ctrl <- nlmeControl(msMaxIter = 500, maxIter = 500)


fm1.power.lis <- nlsList(Area ~ SSpower(DAS, a, b, c),
                         data = lemna.sub.grp.DAS,
                         control = ctrl)

# basic model
fm1.power.nlme <- nlme(fm1.power.lis, 
                       control = ctrl)
# full fixed effect
fm1.power.nlme.FE <- fixef(fm1.power.nlme)

n.acn <- length(unique(lemna.sub.grp.DAS$acn)) - 1
n.temp <- length(unique(lemna.sub.grp.DAS$temperature)) - 1
n <- n.acn + n.temp + n.acn * n.temp
fm2.power.nlme <- update(fm1.power.nlme,
                         fixed = list(a + b + c ~ acn * temperature),
                         start = c(fm1.power.nlme.FE[1], rep(0, n), fm1.power.nlme.FE[2], rep(0, n), fm1.power.nlme.FE[3],rep(0, n)),
                         control = ctrl)
plot(fm2.power.nlme)
```
Residuals are clearly heteroscedascic.
This is expected for longitudinal data and can often be solved by specifying the correlation between.
```{r heteroscedascity}
ctrl <- nlmeControl(msMaxIter = 200, maxIter = 50)
# Continuous autoregressive covariance structure
# need to use DAS_decimal since DAs has two observations per tiimepoint:individual.
# the model runs, but not sure how kosjer this is.
fm3.power.nlme <- update(fm2.power.nlme,
                         correlation = corCAR1(form = ~ DAS_decimal | ID),
                         control = ctrl)
# compare
anova(fm2.power.nlme, fm3.power.nlme)


fm4.power.nlme <- update(fm3.power.nlme,
                           random = a + b + c ~ experiment,
                           control = ctrl)
# try only a (intercept) depending on experiment.
fm5.power.nlme <- update(fm3.power.nlme,
                           random = list(a ~ experiment, b + c ~ 1),
                           control = ctrl)


# varExp solves heteroscedasticity
fm6.power.nlme <- update(fm3.power.nlme,
                         weights = varExp(form = ~ DAS),
                         control = ctrl)
plpot(fm6.power.nlme)
# CAR needed? Phi = 0
fm7.power.nlme <- update(fm2.power.nlme,
                         weights = varExp(form = ~DAS),
                         control = ctrl)
anova(fm6.power.nlme, fm7.power.nlme)
# fm7.power.nlme is slightly better

# include experiment as random effect?
fm8 <- update(fm7.power.nlme,
              random = list(a + b +  c ~ acn * temperature),
              control = ctrl)



# Adding CAR correlation structure improves the model a bit does not decrease the heteroscedascity.
fm4.power.nlme <- update(fm2.power.nlme,
                         correlation = corCAR1(form = ~ DAS_decimal | ID),
                         weights = varPower(form = ~ DAS | ID),
                         control = ctrl)


fm5.power.nlme <- update(fm2.power.nlme,
                         correlation=corCAR1(form = ~ 1 | ID),
                         weights = varIdent(form = ~ 1 | DAS),
                         control = ctrl)




# shoudl be toeplitz
corARMA(,form=~1|id, p=3, q=0)

```






```{r logistic nlme hetero}
ctrl <- nlmeControl(msMaxIter = 500, maxIter = 500)

lemna.sub.grp.conv.df <- as.data.frame(lemna.sub.grp.conv)
lemna.sub.grp.df <- as.data.frame(lemna.sub.grp)

fm2.logis.lis <- nlsList(Area ~ SSlogis(DAS_decimal, Asym, xmid, scal)| ID, data = lemna.sub.grp.df, control = ctrl)

fm2.logis.nlme <- nlme(fm2.logis.lis, control = ctrl)

fm3.logis.nlme <- update(fm3.logis.nlme,
                         fixed = Asym ~ temperature)                   
                       
                       
                       , fixed = list(xmid ~temperature * acn, Asym ~ temperature * acn, scal ~ temperature * acn), data = lemna.sub.grp.conv.df)



plot(fm2.logis.nlme)
fm3.logis.nlme <- update(fm2.logis.nlme, correlation = corCAR1(form = ~ DAS_decimal | ID), control = ctrl)
plot(fm3.logis.nlme)

anova(fm2.logis.nlme, fm3.logis.nlme)

fm4.logis.lis <-  nlsList(Area ~ SSlogis(DAS_decimal, Asym, xmid, scal)|ID, data = lemna.sub.grp.conv.df, control = ctrl)
fm4.logis.nlme <- nlme(fm4.logis.lis,
                       groups = ~ ID,
                       fixed = xmid + Aysm + scal ~ temperature * acn,
                       correlation = corCAR1(form = ~ DAS_decimal | ID),
                       control = ctrl)


fm5.logis.nlme <- nlme(fm4.logis.lis,
                       groups = ~ ID,
                       data = lemna.sub.grp.conv.df,
                       fixed = list(Asym ~ temperature, xmid ~ 1),
                       control = ctrl)

fm1CO2 <- nlme(uptake ~ SSasympOff(conc , Asym, lrc , cO) , data = CO2, fixed = Asym + lrc + cO ~ 1, control = ctrl) 
fm2CO2 <- update(fm1CO2, random = Asym + lrc ~ 1) 
fm2CO2.RE <- ranef(fm2CO2, augFrame = T) 
fm2CO2.RE
plot(fm2CO2.RE, form = ~ Type * Treatment) 

fm3CO2 <- update(fm2CO2,
                 fixed = list (Asym + lrc ~ Type * Treatment, cO ~ 1),
                 start = c(32.4, 0, 0, 0, -4.6, 0, 0, 0, 49.3)) 




test.grpd <- groupedData(Area ~ DAS_decimal | ID, data = lemna.sub.grp.df)
fm1.test <- nlme(Area ~ SSlogis(DAS, Asym, xmid, scal),
                 data = test.grpd,
                 fixed = Asym + xmid + scal ~ acn * experiment,
                 control = ctrl)


lemna.sub.grp.df$DAS <-round(lemna.sub.grp.df$DAS_decimal)
lemna.sub.grp.df <- lemna.sub.grp.df.BU
lemna.sub.grp.df <- lemna.sub.grp.df %>%
  select(ID, acn, temperature, DAS, Area)
  
  [lemna.sub.grp.df$acn %in% c(992, 6038), ]



test.grpd <- groupedData(Area ~ DAS | ID, data = lemna.sub.grp.df)

fm1.test.power <- nlme(Area ~ SSpower(DAS, a, b, c),
                 data = test.grpd,
                 fixed = a + b + c ~ 1,
                 control = ctrl)

fm2.test.power <- update(fm1.test.power,
                         fixed = list(a ~ temperature, b + c ~ 1),
                         start = c(fixef(fm2.test.power)[1], 0, fixef(fm2.test.power)[2:3]))


fm2.test.power <- nlme(Area ~ SSpower(DAS, a, b, c),
                       groups = ~ ID,
                       data = lemna.sub.grp.df,
                       fixed = a + b + c ~ 1,
                       control = ctrl,
                       start = fixef(fm1.test.power))

fm3.test.power <- update(fm2.test.power,
                         data = lemna.sub.grp.df,
                         fixed = list(a ~ temperature, b + c  ~ 1),
                         start = c(fixef(fm2.test.power)[1], 0, fixef(fm2.test.power)[2:3]))


fm2.test.power <- update(fm1.test.power,
                         data = test.grpd,
                         fixed = a ~ temperature)


fm1.test <- nlme(Area ~ SSpower(DAS_decimal, a, b, c), data = test.grpd, fixed = a + b + b ~ temperature, control = ctrl)
update(fm1.test,
       fixed = a + b + c ~ acn * temperature )






plot(fm4.logis.nlme)
fm4.logis.nlme

plot(ranef(fm4.logis.nlme, augFrame = T), form = ~ temperature * acn)

fm5.logis.nlme <- update(fm4.logis.nlme,
                         random = scal ~ 1,
                         control = ctrl)




```

```{r glm}
pheno <- lemna.sub %>%
  group_by(ID) %>%
  mutate(area_scaled = scales::rescale(Area)) %>%
  ungroup
  
  
  


model <- glm(area_scaled ~ DAS_decimal * acn * temperature, family=quasibinomial(link='logit'), data=pheno)

pheno$pred <- predict(model, pheno, type = 'response')
i <- 1
plot(pheno$DAS_decimal[pheno$ID == unique(pheno$ID)[i]], pheno$area_scaled[pheno$ID == unique(pheno$ID)[i]]) + lines(pheno$DAS_decimal[pheno$ID == unique(pheno$ID)[i]], pheno$pred[pheno$ID == unique(pheno$ID)[i]])

```
GLM is not doing a good job.
forces logistic fit too much on the data, whcih look more power law.


```{r power law}
fmla.pow <- as.formula("~(M0^(1-beta) + r*x*(1-beta))^(1/(1-beta))")
Init.pow <- function(mCall, LHS, data){
    xy <- sortedXyData(mCall[["x"]], LHS, data)
    if(nrow(xy) < 4) {stop("Too few distinct x values to fit a power-law")}
	r    <-coef(lm(log(y) ~ x, xy))[2]    # Use the slope from a log fit to the data as an initial guess for r
	M0   <- min(xy$y)		              # Use the minimum y value as an initial guess for M0
	beta <- 0.9	                          # give initial guess of beta as 0.9. don't use beta = 1, as it's undefined (1/0)
    value <- c(M0, r, beta) 
    names(value) <- mCall[c("M0", "r", "beta")]
 	return(value)
	}
SS.pow  <- selfStart(fmla.pow, initial = Init.pow, parameters = c("M0", "r", "beta"))





fm3.lis <- nlsList(Area ~ SS.pow(DAS_decimal, M0, r, beta), data = lemna.sub.grp)
plot(fm3.lis)
plot(augPred(fm3.lis))


# Self-starting power law function written by C. Scherber

powermodel=function(x,a,b,c)
{a+b*x^c}

powermodelInit=function(mCall,LHS,data){
xy=sortedXyData(mCall[["x"]],LHS,data)
lmFit1=lm(xy[,"y"]~1) #for "intercept", a
lmFit2=lm(log(xy[,"y"])~log(xy[,"x"])) #for b and c
coefs1=coef(lmFit1)
coefs2=coef(lmFit2)
a=coefs1
b=exp(coefs2[1])
c=coefs2[2]
value=c(a,b,c)
names(value)=mCall[c("a","b","c")]
value
}

SSpower=selfStart(powermodel,powermodelInit,c("a","b","c"))

##

fm4.lis <- nlsList(Area ~ SSpower(DAS_decimal, a, b, c), data = lemna.sub.grp)
plot(fm4.lis)
plot(augPred(fm4.lis))

fm4.lis.ranef <- as.data.frame(ranef(fm4.lis))
nonconverge <- rownames(fm4.lis.ranef[is.na(fm4.lis.ranef$a), ])

## self-written power law selfstart


```


```{r nlme covar structure}
fm2.nlme <- update(fm1.nlme, fixed = list(Asym ~ temperature))
```

Setup logistic regression
Afterwards djust model for exponential.
Compare with anova






